(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{ou6J:function(e,t,n){"use strict";n.r(t);var v=n("KHd+"),a=Object(v.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"markdown"},[n("h2",[e._v("Validator")]),e._v(" "),e._m(0),e._v(" "),n("p",[e._v("校验器，用于对表单进行验证，并提示相应的错误信息。")]),e._v(" "),n("h3",[e._v("示例")]),e._v(" "),n("ul",[e._m(1),e._v(" "),e._m(2),e._v(" "),n("li",[n("p",[e._v("自定义提示插槽")]),e._v(" "),n("p",[e._v("用 messages 属性只能配置提示信息文案，但当你想加图标等自定义提示时，可以使用 message 插槽。这是一个作用域插槽，提供的作用域参数基本上能够满足所有的灵活定制需求，参数包括了：dirty，待检验的数据是否有修改过；message，首条没通过的规则的提示信息；result，对象，内含每条规则的校验结果和提示信息，如{ required: { valid: false, invalid: true, message: '必填' } }。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-validator v-model="valid" :model="text" :rules="rules" :messages="messages">\n  <cube-input v-model="text" placeholder="component name"></cube-input>\n  <div slot="message" class="custom-msg" slot-scope="props">\n    <div v-if="(props.dirty || props.validated) && !valid">\n      <i class="dd-cubeic-important"></i> '+e._s(e.props.message)+'\n      <div>\n        <span v-for="(item, index) in Object.values(props.result)"\n          :key="index" v-if="item.inValid">\n          '+e._s(e.item.message+" ")+"\n        </span>\n      </div>\n    </div>\n  </div>\n</cube-validator>\n")])]),e._v(" "),e._m(3),e._v(" "),e._m(4)]),e._v(" "),e._m(5),e._v(" "),e._m(6)]),e._v(" "),n("h3",[e._v("Props")]),e._v(" "),e._m(7),e._v(" "),n("h3",[e._v("Slot")]),e._v(" "),e._m(8),e._v(" "),n("h3",[e._v("事件")]),e._v(" "),e._m(9),e._v(" "),n("h3",[e._v("实例方法")]),e._v(" "),e._m(10),e._v(" "),n("h3",[e._v("规则")]),e._v(" "),e._m(11),e._v(" "),n("h3",[e._v("添加默认提示信息")]),e._v(" "),n("p",[e._v("首先我们看一下内置的默认提示信息是怎样的，如果你需要修改，可以通过 addMessage 修改相应子属性。")]),e._v(" "),e._m(12),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("const messages = {\n  required: '此为必填项',\n  type: {\n    string: '请输入字符',\n    number: '请输入数字',\n    array: '数据类型应为数组',\n    date: '请选择有效日期',\n    email: '请输入有效邮箱',\n    tel: '请输入有效的手机号码',\n    url: '请输入有效网址'\n  },\n  min: {\n    string: '至少输入 "+e._s(e.config)+" 位字符',\n    number: '不得小于 "+e._s(e.config)+"',\n    array: '请选择至少 "+e._s(e.config)+" 项',\n    date: '请选择 "+e._s(e._f("toLocaleDateString")(e.config,"yyyy年MM月dd日"))+" 之后的时间',\n    email: '至少输入 "+e._s(e.config)+" 位字符',\n    tel: '至少输入 "+e._s(e.config)+" 位字符',\n    url: '至少输入 "+e._s(e.config)+" 位字符'\n  },\n  max: {\n    string: '请勿超过 "+e._s(e.config)+" 位字符',\n    number: '请勿大于 "+e._s(e.config)+"',\n    array: '最多选择 "+e._s(e.config)+" 项',\n    date: '请选择 "+e._s(e._f("toLocaleDateString")(e.config,"yyyy年MM月dd日"))+" 之前的时间',\n    email: '请勿超过 "+e._s(e.config)+" 位字符',\n    tel: '请勿超过 "+e._s(e.config)+" 位字符',\n    url: '请勿超过 "+e._s(e.config)+" 位字符'\n  },\n  len: {\n    string: '请输入 "+e._s(e.config)+" 位字符',\n    number: '长度应等于 "+e._s(e.config)+"',\n    array: '请选择 "+e._s(e.config)+" 项',\n    date: '请选择 "+e._s(e._f("toLocaleDateString")(e.config,"yyyy年MM月dd日"))+" 之前的时间',\n    email: '请输入 "+e._s(e.config)+" 位字符',\n    tel: '请输入 "+e._s(e.config)+" 位字符',\n    url: '请输入 "+e._s(e.config)+" 位字符'\n  },\n  pattern: '格式错误',\n  custom: '未通过校验',\n  notWhitespace: '空白内容无效'\n}\n")])]),e._v(" "),e._m(13),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("import Vue from 'vue'\nimport { Validator } from 'cube-ui'\n\n// need use Validator\nVue.use(Validator)\n\nValidator.addMessage('required', '必填')\n\n// 覆盖 min.date 的提示消息\nValidator.addMessage('min', {\n  date: '请选择 "+e._s(e._f("tips")(e._f("toLocaleDateString")(e.config,"yyyy年MM月dd日"),"请重新输入"))+" 之后的时间'\n})\nValidator.addHelper('tips', function(result, arg1) {\n  // 必须要返回提示消息\n  return `${result}, ${arg1}`\n})\n")])]),e._v(" "),n("p",[e._v("如上，组件内部解析默认的消息是类似于 Vue filter 的机制。")]),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),n("p",[e._v("通过 Validator.addHelper 方法注册的工具函数实际上是在 Locale.helpers 的命名空间下，你也可以导入 Locale 模块并且通过 Locale.addHelper 注册工具函数，两者都是指向同一块内存地址。")]),e._v(" "),n("h3",[e._v("添加类型")]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22)])},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("blockquote",[n("p",[e._v("1.5.0 新增")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("li",[n("p",[e._v("基本用法")]),e._v(" "),n("p",[e._v("Validator 作为一个独立的组件，通过 model 属性绑定它需要检验的数据；rules 定义验证规则，在 rules 规则中，可以配置 type、required 等内置规则，也可以用 pattern 添加校验的正则表达式，或 custom 自定义验证函数，具体细节可见后面的规则；针对各类规则，我们有比较完善的默认提示文案，具体可见后面的默认提示文案；同时，你也可以用 messages 属性用于自定义提示信息。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-input v-model="text" placeholder="E-mail"></cube-input>\n<cube-validator v-model="valid" :model="text" :rules="rules" :messages="messages"></cube-validator>\n')])]),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("export default {\n  data() {\n    return {\n      text: '',\n      valid: undefined,\n      rules: {\n        required: true,\n        type: 'email',\n        pattern: /didi.com$/,\n        custom: (val) => {\n          return val.length >= 12\n        }\n      },\n      messages: {\n        pattern: 'The E-mail suffix need to be didi.com.',\n        custom: 'The E-mail need contain at least 12 characters.'\n      },\n    }\n  }\n}\n")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("li",[n("p",[e._v("给表单添加警告样式")]),e._v(" "),n("p",[e._v("如果想给表单组件添加警告样式，可以通过把表单组件作为默认插槽，插在 Validator 组件内。因为当未通过验证时，Validator 组件会有一个样式类，cube-validator_warn，给这个类下的表单元素增加样式即可。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-validator :model="text" :rules="rules" v-model="valid">\n  <cube-input v-model="text"></cube-input>\n</cube-validator>\n')])]),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("export default {\n  data() {\n    return {\n      text: '',\n      valid: undefined,\n      rules: {\n        required: true,\n        type: 'email',\n        min: 6\n      }\n    }\n  }\n}\n")])]),e._v(" "),n("pre",[n("code",{staticClass:"language-css"},[e._v("// add warning style to input\n.cube-validator_warn\n  input\n    border: solid 1px yellow\n")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("pre",[n("code",{staticClass:"language-js"},[e._v("export default {\n  data() {\n    return {\n      valid: undefined,\n      text: '',\n      rules: {\n        type: 'string',\n        pattern: /^cube-/,\n        min: 8,\n        max: 10\n      },\n      messages: {\n        pattern: 'The component name need start with \"cube-\"'\n      },\n    }\n  }\n}\n")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("pre",[n("code",{staticClass:"language-css"},[e._v(".custom-msg\n  color: orange\n")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("li",[n("p",[e._v("异步校验<sup>1.8.0+</sup>")]),e._v(" "),n("p",[e._v("支持校验规则是异步的情况，约定如果校验规则函数的返回值是一个函数（"),n("strong",[e._v("该函数接收一个 "),n("code",[e._v("resolve")]),e._v(" 回调，如果调用传入 "),n("code",[e._v("true")]),e._v(" 则代表校验成功，否则都视为失败")]),e._v("）或者是一个 Promise 对象（"),n("strong",[n("code",[e._v("resolve")]),e._v(" 的值是 "),n("code",[e._v("true")]),e._v(" 的话就是校验成功，否则都视为失败")]),e._v("）那么就是异步校验，同时在校验的过程中会派发 "),n("code",[e._v("validating")]),e._v(" 事件，在校验后派发 "),n("code",[e._v("validated")]),e._v(" 事件。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<div class="validator-item">\n  <p>Async validate: </p>\n  <cube-validator\n    v-model="valid"\n    :model="captcha"\n    :rules="rules"\n    :messages="messages"\n    :immediate="immediate"\n    @validating="validatingHandler"\n    @validated="validatedHandler">\n    <cube-input v-model="captcha" placeholder="Please input captcha"></cube-input>\n  </cube-validator>\n</div>\n')])]),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("export default {\n  data() {\n    return {\n      valid: undefined,\n      captcha: '',\n      rules: {\n        type: 'number',\n        required: true,\n        len: 6,\n        captchaCheck: (val) => {\n          return (resolve) => {\n            setTimeout(() => {\n              resolve(val === '123456')\n            }, 1000)\n          }\n          /** or return promise:\n          return new Promise((resolve) => {\n            setTimeout(() => {\n              resolve(val === '123456')\n            }, 1000)\n          })\n          **/\n        }\n      },\n      messages: {\n        captchaCheck: 'Please input \"123456\"'\n      }\n    }\n  },\n  methods: {\n    validatingHandler() {\n      console.log('validating')\n    },\n    validatedHandler() {\n      console.log('validated')\n    }\n  }\n}\n")])]),e._v(" "),n("p",[e._v("上述的 "),n("code",[e._v("captchaCheck")]),e._v(" 就是一个异步校验规则，校验过程需花费 1 秒。")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("li",[n("p",[e._v("提交")]),e._v(" "),n("p",[e._v("虽然提交不属于 Validator 组件，但它往往与校验结果相关联着。所以这里说一下我们对提交的一种最佳实践，可供参考。重点在于对同时存在多个校验任务，以及提交时无论是否填写过表单都要进行校验，这两个需求的处理。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-input v-model="text0" placeholder="Required"/>\n<cube-validator ref="validator0" v-model="result[0]" :model="text0" :rules="rules0"/>\n<cube-input v-model="text1" placeholder="E-mail"/>\n<cube-validator ref="validator1" v-model="result[1]" :model="text1" :rules="rules1"/>\n<cube-input v-model="text2" placeholder="TEL"/>\n<cube-validator ref="validator2" v-model="result[2]" :model="text2" :rules="rules2"/>\n<cube-button @click="submit">Submit</cube-button>\n')])]),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("export default {\n  data() {\n    return {\n      result: [undefined, undefined, undefined],\n      text0: '',\n      rules0: {\n        required: true,\n      },\n      text1: '',\n      rules1: {\n        type: 'email',\n      },\n      text2: '',\n      rules2: {\n        type: 'tel',\n      },\n      trigger: false\n    }\n  },\n  methods: {\n    submit() {\n      const p1 = this.$refs.validator0.validate()\n      const p2 = this.$refs.validator1.validate()\n      const p3 = this.$refs.validator2.validate()\n      Promise.all([p1, p2, p3]).then(() => {\n        if (this.result.every(item => item)) {\n          this.$createToast({\n            type: 'correct',\n            txt: 'Submited',\n            time: 1000\n          }).show()\n        }\n      })\n    }\n  }\n}\n")])]),e._v(" "),n("p",[e._v("对于有多个校验同时通过才可提交的情况，为了不用一个一个去取校验结果变量，可以把这组校验结果存在一个数组，在提交时，遍历这个数组即可。")]),e._v(" "),n("p",[e._v("通过调用 Validator 实例的 "),n("code",[e._v("validate")]),e._v(" 方法可以去校验处理，从 1.8.0 版本后支持回调参数且如果浏览器支持 Promise 那么返回值就是 Promise 对象。")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("table",[n("thead",[n("tr",[n("th",[e._v("参数")]),e._v(" "),n("th",[e._v("说明")]),e._v(" "),n("th",[e._v("类型")]),e._v(" "),n("th",[e._v("可选值")]),e._v(" "),n("th",[e._v("默认值")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("model")]),e._v(" "),n("td",[e._v("必传，指定需要校验的数据")]),e._v(" "),n("td",[e._v("Any")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("-")])]),e._v(" "),n("tr",[n("td",[e._v("v-model")]),e._v(" "),n("td",[e._v("校验结果，是否通过验证")]),e._v(" "),n("td",[e._v("Boolean")]),e._v(" "),n("td",[e._v("true/false")]),e._v(" "),n("td",[e._v("true")])]),e._v(" "),n("tr",[n("td",[e._v("rules")]),e._v(" "),n("td",[e._v("校验规则，具体见后面的内置规则和创建规则")]),e._v(" "),n("td",[e._v("Object")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("{}")])]),e._v(" "),n("tr",[n("td",[e._v("messages")]),e._v(" "),n("td",[e._v("自定义提示信息")]),e._v(" "),n("td",[e._v("Object")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("{}")])]),e._v(" "),n("tr",[n("td",[e._v("immediate")]),e._v(" "),n("td",[e._v("初始时是否立即校验")]),e._v(" "),n("td",[e._v("Boolean")]),e._v(" "),n("td",[e._v("true/false")]),e._v(" "),n("td",[e._v("false")])]),e._v(" "),n("tr",[n("td",[e._v("disabled<sup>1.7.0+</sup>")]),e._v(" "),n("td",[e._v("是否禁用")]),e._v(" "),n("td",[e._v("Boolean")]),e._v(" "),n("td",[e._v("true/false")]),e._v(" "),n("td",[e._v("false")])])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("table",[n("thead",[n("tr",[n("th",[e._v("名字")]),e._v(" "),n("th",[e._v("说明")]),e._v(" "),n("th",[e._v("作用域参数")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("default")]),e._v(" "),n("td",[e._v("表单组件")]),e._v(" "),n("td",[e._v("-")])]),e._v(" "),n("tr",[n("td",[e._v("message")]),e._v(" "),n("td",[e._v("错误提示")]),e._v(" "),n("td",[e._v("dirty: 待检验的数据是否有修改过 <br> validating: 是否正在校验 <br> validated: 是否校验过 <br> message: 首条没通过的规则的提示信息 <br> result: 对象，内含每条规则的校验结果和提示信息，如{ required: { valid: false, invalid: true, message: '必填' } }")])])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("table",[n("thead",[n("tr",[n("th",[e._v("事件名")]),e._v(" "),n("th",[e._v("说明")]),e._v(" "),n("th",[e._v("参数")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("validating")]),e._v(" "),n("td",[e._v("正在校验（只在异步场景下触发）")]),e._v(" "),n("td",[e._v("-")])]),e._v(" "),n("tr",[n("td",[e._v("validated")]),e._v(" "),n("td",[e._v("校验完成（只在异步场景下触发）")]),e._v(" "),n("td",[e._v("valid: 校验是否成功")])]),e._v(" "),n("tr",[n("td",[e._v("msg-click")]),e._v(" "),n("td",[e._v("错误消息点击")]),e._v(" "),n("td",[e._v("-")])]),e._v(" "),n("tr",[n("td",[e._v("input")]),e._v(" "),n("td",[e._v("绑定值变化时触发")]),e._v(" "),n("td",[e._v("更新后的绑定值")])])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("table",[n("thead",[n("tr",[n("th",[e._v("方法名")]),e._v(" "),n("th",[e._v("说明")]),e._v(" "),n("th",[e._v("参数")]),e._v(" "),n("th",[e._v("返回值")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("validate(cb)")]),e._v(" "),n("td",[e._v("校验")]),e._v(" "),n("td",[e._v("cb: 校验完成后回调函数，主要用于异步校验场景，调用参数为 valid 的值")]),e._v(" "),n("td",[e._v("如果支持 Promise 返回值为 Promise 对象（只有 resolved 状态，值为 valid），否则返回值为 undefined")])])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[n("p",[e._v("已有规则")]),e._v(" "),n("p",[e._v("目前已有的内置规则，有 required、type、min、max、len、notWhitespace、pattern、custom。")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("参数")]),e._v(" "),n("th",[e._v("说明")]),e._v(" "),n("th",[e._v("类型")]),e._v(" "),n("th",[e._v("可选值")]),e._v(" "),n("th",[e._v("示例")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("required")]),e._v(" "),n("td",[e._v("必填")]),e._v(" "),n("td",[e._v("Boolean")]),e._v(" "),n("td",[e._v("true/false")]),e._v(" "),n("td",[e._v("true")])]),e._v(" "),n("tr",[n("td",[e._v("type")]),e._v(" "),n("td",[e._v("类型")]),e._v(" "),n("td",[e._v("String")]),e._v(" "),n("td",[e._v("'string', 'number', 'array', 'date', 'email', 'tel', 'url'")]),e._v(" "),n("td",[e._v("'tel'")])]),e._v(" "),n("tr",[n("td",[e._v("min")]),e._v(" "),n("td",[e._v("当类型为 number 或 date 时，表示待校验的数据必须大于等于 min；其它类型，表示待校验数据的长度必须大于等于 min")]),e._v(" "),n("td",[e._v("Number")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("6")])]),e._v(" "),n("tr",[n("td",[e._v("max")]),e._v(" "),n("td",[e._v("当类型为 number 或 date 时，表示待校验的数据必须小于等于 max；其它类型，表示待校验数据的长度必须小于等于 max")]),e._v(" "),n("td",[e._v("Number")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("8")])]),e._v(" "),n("tr",[n("td",[e._v("len")]),e._v(" "),n("td",[e._v("当类型为 number 或 date 时，表示待校验的数据必须等于 len；其它类型，表示待校验数据的长度必须等于 len")]),e._v(" "),n("td",[e._v("Number")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("7")])]),e._v(" "),n("tr",[n("td",[e._v("notWhitespace")]),e._v(" "),n("td",[e._v("不允许全是空白符")]),e._v(" "),n("td",[e._v("Boolean")]),e._v(" "),n("td",[e._v("true/false")]),e._v(" "),n("td",[e._v("true")])]),e._v(" "),n("tr",[n("td",[e._v("pattern")]),e._v(" "),n("td",[e._v("正则匹配")]),e._v(" "),n("td",[e._v("RegExp")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("/1$/")])]),e._v(" "),n("tr",[n("td",[e._v("custom")]),e._v(" "),n("td",[e._v("自定义验证函数，当返回值严格等于 true 时，代表验证通过。")]),e._v(" "),n("td",[e._v("Function")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("val => val.length === 7")])])])])]),e._v(" "),n("li",[n("p",[e._v("添加规则")]),e._v(" "),n("p",[e._v("除了已有的内置规则，你还可以使用 Validator 的 addRule 方法，添加自定义的公共规则，以及 addMessage 方法添加相应的默认提示信息。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("import Vue from 'vue'\nimport { Validator } from 'cube-ui'\n// need use Validator\nVue.use(Validator)\nValidator.addRule('odd', (val, config, type) => !config || Number(val) % 2 === 1)\nValidator.addMessage('odd', 'Please input odd.')\n")])]),e._v(" "),n("p",[e._v("接下来你就可以在 rules 的配置中使用 odd 规则了：")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-validator v-model="valid" :model="text" :rules="rules">\n  <cube-input v-model="text3" placeholder="odd"></cube-input>\n</cube-validator>\n')])]),e._v(" "),n("pre",[n("code",{staticClass:"language-js"},[e._v("export default {\n  data() {\n    return {\n      text: '100',\n      valid: undefined,\n      rules: {\n        type: 'number',\n        odd: true\n      }\n    }\n  }\n}\n")])])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[e._v("内置的默认提示信息")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[e._v("修改已有提示信息")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("config")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("比如你配置的规则是：{type: 'date', min: '2018-10-10'}，那么对于 "),n("code",[e._v("min")]),e._v(" 下面的 "),n("code",[e._v("date")]),e._v(" 的消息模板中的 "),n("code",[e._v("config")]),e._v(" 字段的值就是 '2018-10-10', 因为校验的是一个 "),n("code",[e._v("date")]),e._v(" 类型，"),n("code",[e._v("min")]),e._v(" 对应的字段可以是一个 "),n("code",[e._v("timestamp")]),e._v(" (日期时间戳)或者类似于日期格式的字符串 "),n("code",[e._v("yyyy-MM-dd mm:ss")]),e._v(" 或者 "),n("code",[e._v("yyyy/MM/dd mm:ss")]),e._v("。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("toLocaleDateString")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("内置的helper函数，第一个参数是你配置的 config 值，第二个参数是你期望的日期格式， 如上则为 "),n("code",[e._v("'yyyy年MM月dd日'")]),e._v(", 接受类似于 "),n("code",[e._v("yyyy-MM-dd mm:ss")]),e._v(" 格式，你也可以通过如下的方式注册你自己的helper函数。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",{staticClass:"language-js"},[this._v("Validator.addHelper('fnName', (result, arg1) => {\n  // result -> 上一个helper函数返回的值或者 config 值，如上例则是'2018-10-10'\n  // arg1 -> 你在消息模板传入的字符串, 如上例则是'请重新输入'\n  let ret\n\n  // 实现自己的逻辑\n  ret = result + arg1\n\n  // 必须返回处理过后的消息\n  return ret\n})\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("添加新的类型")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",{staticClass:"language-js"},[this._v("import { Validator } from 'cube-ui'\n\nValidator.addType('yourType', (val) => {\n  return typeof val === 'string' && /^[a-z0-9_-]+/i.test(val)\n})\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("修改已有类型")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",[t("code",{staticClass:"language-js"},[this._v("import { Validator } from 'cube-ui'\n\nValidator.addType('email', (val) => {\n  return typeof val === 'string' && /^[a-z0-9_-]+@[a-z0-9_-]+(\\.[a-z0-9_-]+)$/i.test(val)\n})\n")])])}],!1,null,null,null);t.default=a.exports}}]);