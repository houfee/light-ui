(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{L2zW:function(e,l,n){"use strict";n.r(l);var t=n("KHd+"),o=Object(t.a)({},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("div",{staticClass:"markdown"},[n("h2",[e._v("Scroll")]),e._v(" "),e._m(0),e._v(" "),n("h3",[e._v("滚动原理")]),e._v(" "),n("p",[e._v("由于 better-scroll 的滚动原理为：在滚动方向上，第一个子元素的长度超过了容器的长度。")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),n("h3",[e._v("示例")]),e._v(" "),n("p",[e._v("7 个示例代码快速了解如何使用 Scroll 组件。")]),e._v(" "),n("ul",[e._m(5),e._v(" "),n("li",[e._m(6),e._v(" "),e._m(7),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-scroll\n  ref="scroll"\n  :data="items"\n  direction="horizontal"\n  class="horizontal-scroll-list-wrap">\n  <ul class="list-wrapper">\n    <li v-for="item in items" class="list-item">'+e._s(e.item)+"</li>\n  </ul>\n</cube-scroll>\n")])]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10)]),e._v(" "),e._m(11),e._v(" "),n("li",[e._m(12),e._v(" "),e._m(13),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-scroll\n  ref="scroll"\n  :scroll-events="[\'scroll\']"\n  :options="scrollOptions"\n  @scroll="onScrollHandle"\n  @pulling-down="onPullingDown">\n  <img src="http://om0jxp12h.bkt.clouddn.com/jd_content.JPG">\n  <template slot="pulldown" slot-scope="props">\n    <div v-if="props.pullDownRefresh"\n      class="cube-pulldown-wrapper"\n      :style="pullDownStyle">\n      <div class="pulldown-content">\n        <img src="http://om0jxp12h.bkt.clouddn.com/pulldow-img.jpg">\n        <span v-if="props.beforePullDown">'+e._s(e.pullDownTip)+'</span>\n        <template v-else>\n          <span v-if="props.isPullingDown">正在更新...</span>\n          <span v-else>更新成功</span>\n        </template>\n      </div>\n    </div>\n  </template>\n</cube-scroll>\n')])]),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),e._m(16)]),e._v(" "),n("li",[e._m(17),e._v(" "),e._m(18),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<div class="nav-scroll-list-wrap">\n  <cube-scroll ref="navScroll" direction="horizontal">\n    <ul class="nav-wrapper">\n      <li v-for="(item, index) in navTxts" :key="index" class="nav-item">'+e._s(e.item)+'</li>\n    </ul>\n  </cube-scroll>\n  <div class="more-wrapper">\n    <span class="more"></span>\n  </div>\n</div>\n<div class="content-scroll-wrapper">\n  <div class="content-scroll-list-wrap" ref="scrollWrapper">\n    <cube-scroll\n      ref="contentScroll"\n      :data="content"\n      :options="options"\n      @pulling-down="onPullingDown"\n      @pulling-up="onPullingUp">\n      <ul class="imgs-wrapper">\n        <li v-for="(item, index) in content" :key="index" class="imgs-item">\n          <img :src="item.url">\n        </li>\n      </ul>\n      <template slot="pulldown" slot-scope="props">\n        <div v-if="props.pullDownRefresh"\n          class="cube-pulldown-wrapper"\n          :style="props.pullDownStyle">\n          <div v-if="props.beforePullDown"\n            class="before-trigger"\n            :style="{paddingTop: props.bubbleY + \'px\'}">\n            <span :class="{rotate: props.bubbleY > options.pullDownRefresh.threshold - 60}">↓</span>\n          </div>\n          <div class="after-trigger" v-else>\n            <div v-show="props.isPullingDown" class="loading">\n              <cube-loading></cube-loading>\n            </div>\n            <transition name="success">\n              <div v-show="!props.isPullingDown" class="text-wrapper"><span class="refresh-text">今日头条推荐引擎有x条更新</span></div>\n            </transition>\n          </div>\n        </div>\n      </template>\n    </cube-scroll>\n  </div>\n</div>\n')])]),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22)]),e._v(" "),n("li",[e._m(23),e._v(" "),e._m(24),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-scroll\n  ref="scroll1"\n  class="scroll-list-outer-wrap">\n  ...\n  <cube-scroll\n    ref="scroll2"\n    class="scroll-list-inner-wrap"\n    nest-mode="native">\n    <ul class="cube-scroll-list">\n      <li class="cube-scroll-item border-bottom-1px"\n        v-for="(item, index) in items2"\n        :key="index">'+e._s(e.item)+"</li>\n    </ul>\n  </cube-scroll>\n  ...\n</cube-scroll>\n")])])]),e._v(" "),n("li",[e._m(25),e._v(" "),e._m(26),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-scroll\n  ref="scroll"\n  :data="items1"\n  direction="horizontal"\n  class="outer-horizontal-scroll">\n  <ul class="list-wrapper">\n    <li v-for="item in items1" class="list-item">'+e._s(e.item)+'</li>\n    <li class="list-item inner-horizontal-scroll">\n      <cube-scroll\n        ref="scroll"\n        :data="items2"\n        direction="horizontal"\n        nest-mode="free">\n        <ul class="list-wrapper">\n          <li v-for="item in items2" class="list-item">'+e._s(e.item)+'</li>\n        </ul>\n      </cube-scroll>\n    </li>\n    <li v-for="item in items1" class="list-item">'+e._s(e.item)+"</li>\n  </ul>\n</cube-scroll>\n")])])])]),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),e._m(29),e._v(" "),n("p",[e._v("1）利用 div 标签模拟 textarea，实现内容区域高度自适应。")]),e._v(" "),n("p",[e._v("2）利用 textarea 配合 js，实现高度自适应。")]),e._v(" "),e._m(30),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<cube-scroll\n  ref="scrollOuter"\n  :options="optionsOuter"\n  class="scroll-outer">\n  ...\n  <div class="editable-div-wrapper" :class="{\'editable-div_active\': isFocusDiv}">\n    <cube-scroll\n      ref="divWrapScroll"\n      :options="options">\n      <div ref="editablediv" contenteditable="true" class="editable-div"\n        @focus="onFocusDiv"\n        @blur="onBlurDiv"\n        @input="onInputDiv">\n      </div>\n    </cube-scroll>\n    <span class="editable-div-indicator">'+e._s(e.divValueCount)+'</span>\n  </div>\n  <div class="cube-textarea-wrapper" :class="{\'cube-textarea_active\': isFocusNative}">\n    <cube-scroll\n      ref="nativeWrapScroll"\n      :options="options">\n      <textarea\n        ref="textarea"\n        v-model="textareaValue"\n        @input="onInputNative"\n        @focus="onFocusNative"\n        @blur="onBlurNative"\n        :placeholder="placeholder"\n        class="cube-textarea">\n      </textarea>\n    </cube-scroll>\n    <span class="cube-textarea-indicator">'+e._s(e.textareaValueCount)+"</span>\n  </div>\n  ...\n</cube-scroll>\n``` --\x3e\n\n### Props 配置\n\n| 参数 | 说明 | 类型 | 可选值 | 默认值 |\n| - | - | - | - | - |\n| data | 用于列表渲染的数据 | Array | - | [] |\n| direction | 滚动方向 | String | 'vertical', 'horizontal' | 'vertical' |\n| options | better-scroll 配置项，具体请参考[BS 官方文档](https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html) | Object | - | {<br>  observeDOM: true,<br>  click: true,<br>  probeType: 1,<br>  scrollbar: false,<br>  pullDownRefresh: false,<br>  pullUpLoad: false<br>} |\n| scrollEvents<sup>1.9.0</sup> | 配置需要派发的 scroll 事件 | Array | 可包含子项：'scroll', 'before-scroll-start', 'scroll-end' | [] |\n| listenScroll | 是否派发 scroll 事件。`即将废弃`，推荐使用 `scroll-events` 属性 | Boolean | true/false | false |\n| listenBeforeScroll | 是否派发 before-scroll-start 事件。`即将废弃`，推荐使用 `scroll-events` 属性 | Boolean | true/false | false |\n| refreshDelay | data属性的数据更新后，scroll 的刷新延时 | Number | - | 20 |\n| nestMode<sup>1.12.0</sup> | 嵌套滚动模式，默认是`none`，即不做嵌套处理。`native`只在开始滚动时判断是否到达边界并开启外层滚动，与浏览器原生的嵌套滚动保持一致。`free`模式下，内层滚动过程中只要触发边界，便会开启外层滚动。| String | 'none', 'native', 'free' | 'none' |\n\n`options`中 better-scroll 的几个常用配置项，`scrollbar`、`pullDownRefresh`、`pullUpLoad`这三个配置即可设为 `Boolean`（`false` 关闭该功能，`true` 开启该功能，并使用默认子配置），也可设为`Object`，开启该功能并具体定制其子配置项。\n\n- `scrollbar` 子配置项\n\n| 参数 | 说明 | 类型 | 可选值 | 默认值 |\n| - | - | - | - | - |\n| fade | 是否淡入淡出 | Boolean | true/false | false |\n\n- `pullDownRefresh` 子配置项\n\n| 参数 | 说明 | 类型 | 可选值 | 默认值 |\n| - | - | - | - | - |\n| threshold | 下拉刷新动作的下拉距离阈值 | Number | - | 90 |\n| stop | 回弹停留的位置 | Number | - | 组件会自动计算回弹时显示的元素高度作为默认值 |\n| stopTime | 刷新成功的文案显示时间 | Number | - | 600 |\n| txt | 刷新成功的文案 | String | - | 'Refresh success' |\n\n- `pullUpLoad` 子配置项\n\n| 参数 | 说明 | 类型 | 可选值 | 默认值 |\n| - | - | - | - | - |\n| threshold | 上拉刷新动作的上拉距离阈值 | Number | - | 0 |\n| txt | 上拉加载的相关文案 | Object | - | { more: '', noMore: '' } |\n| visible<sup>1.12.21</sup> | 内容不满一屏时，txt 文案是否可见 | Boolean | true/false | false |\n\n> 当开启 pullUpLoad，且内容较少，内容高度小于容器时，默认情况下，`pullUpLoad.txt` 配置的文案如“上滑加载更多”，需要上拉后才能看到。如果希望无需上拉即可看到提示文案，可以设置 `pullUpLoad.visible` 为 `true`。\n\n### 插槽\n\n| 名字 | 说明 | 作用域参数 |\n| - | - | - |\n| default | 基于`data`属性渲染的列表 | - |\n| pulldown | 位于列表上方，会在下拉刷新时显示 | pullDownRefresh: 是否开启了下拉刷新功能 <br> pullDownStyle: 移入移出的样式 <br> beforePullDown: 是否正在做下拉操作 <br> isPullingDown: 是否正在拉取数据 <br> bubbleY: 当前下拉的距离 - 50|\n| pullup | 位于列表下方，会在上拉加载时显示 | pullUpLoad: 是否开启了上拉加载功能 <br> isPullUpLoad: 是否正在加载数据 |\n\n### 事件\n\n| 事件名 | 说明 | 参数 |\n| - | - | - |\n| click | 点击列表项时触发 | item - 该列表项的数据 |\n| scroll | 当 `scroll-events` 包含 `scroll` 时，根据 probeType 的值决定派发时机 | Object {x, y} - 实时滚动位置的坐标 |\n| before-scroll-start | 当 `scroll-events` 包含 `before-scroll-start` 时，在滚动开始之前触发 | - |\n| scroll-end<sup>1.9.0</sup> | 当 `scroll-events` 包含 `scroll-end` 时，在滚动结束时触发 | Object {x, y} - 实时滚动位置的坐标 |\n| pulling-down | 当 pullDownRefresh 属性为 true 时，在下拉超过阈值时触发 | - |\n| pulling-up | 当 pullUpLoad 属性为 true 时，在上拉超过阈值时触发 | - |\n\n### 方法\n\n| 方法名 | 说明 | 参数 |\n| - | - | - |\n| scrollTo(x, y, time, ease) | 滚动到指定位置 | x: number, 横向位置<br> y: number, 纵向位置<br> time: number, 过渡动画时间 (ms)<br> ease: EasingFn, 缓动曲线 |\n| forceUpdate(dirty, nomore<sup>1.12.21</sup>) | 标记上拉下拉结束，强制重新计算可滚动距离 | dirty: boolean, 标识有数据更新，默认为 false。<br>nomore: boolean, pullUpLoad 中标识没有更多数据，默认为 false。1.12.21版本后支持 nomore 参数，当 nomore 为 true 时，上拉加载展示 `pullUpLoad.txt.nomore` 值，但当 dirty 为 false 时，nomore 无效。|\n| disable() | 禁用滚动 | - |\n| enable() | 启用滚动，默认是开启滚动的。 | - |\n| resetPullUpTxt() | 当从无更多切换到有更多时，重置上拉文本内容 | - |\n| refresh() | 刷新，重新计算高度且刷新 BetterScroll 实例 | - |\n\n\n### 内部属性\n\n| 属性名 | 说明 |\n| - | - |\n| scroll | 可以通过该属性获得内部实现滚动核心的 BScoll 实例，从而获得更多 BScoll 的底层能力，如监听`touchEnd`事件，获得滚动中的中间状态等，具体可查看[ better-scroll 文档](http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/) |\n")])])])},[function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("滚动列表，提供了优质的原生滚动体验，便捷的配置项和事件，是一个基于"),n("code",[e._v("better-scroll")]),e._v("进行封装的组件。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("那么对于 Scroll 组件，其实就是内容元素"),n("code",[e._v(".cube-scroll-content")]),e._v("在滚动方向上的长度必须大于容器元素 "),n("code",[e._v(".cube-scroll-wrapper")]),e._v("。根据滚动方向的不同，有以下两种情况：")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("1）纵向滚动："),n("strong",[e._v("内容元素的高度必须大于容器元素")]),e._v("。由于容器元素的高度默认会被子元素的高度撑开，所以为了满足我们的滚动前提，你需要给 Scroll 组件的 "),n("code",[e._v(".cube-scroll-wrapper")]),e._v("元素一个非弹性高度。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("2）横向滚动："),n("strong",[e._v("内容元素的宽度必须大于容器元素")]),e._v("。由于在默认情况下，子元素的宽度不会超过容器元素，所以需要给 Scroll 组件的 "),n("code",[e._v(".cube-scroll-content")]),e._v(" 元素设置大于 "),n("code",[e._v(".cube-scroll-wrapper")]),e._v(" 的宽度。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("blockquote",[n("p",[e._v("注意：任何时候如果出现无法滚动的情况，都应该首先查看内容元素"),n("code",[e._v(".cube-scroll-content")]),e._v("的元素高度/宽度是否大于容器元素"),n("code",[e._v(".cube-scroll-wrapper")]),e._v("的高度/宽度。这是内容能够滚动的前提条件。"),n("strong",[e._v("如果内容存在图片的情况，可能会出现 DOM 元素渲染时图片还未下载，因此内容元素的高度小于预期，出现滚动不正常的情况。此时你应该在图片加载完成后，比如 onload 事件回调中，手动调用 Scroll 组件的 "),n("code",[e._v("refresh()")]),e._v(" 方法，它会重新计算滚动距离。")]),e._v(" Scroll 相关常见问题可以查看 "),n("a",{attrs:{href:"https://github.com/cube-ui/question-answer/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+scroll"}},[e._v("Cube-UI/Question-Answer")]),e._v(".")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("li",[n("p",[n("strong",[e._v("1. 基本使用 - Default")])]),e._v(" "),n("p",[e._v("通过设置 "),n("code",[e._v("data")]),e._v(" 属性为一个数组，即可生成能够在容器内优雅滚动的列表。完整示例代码在"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/default.vue"}},[e._v("这里")]),e._v("。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<div class="scroll-list-wrap">\n  <cube-scroll\n    ref="scroll"\n    :data="items"\n    :options="options">\n  </cube-scroll>\n</div>\n')])]),e._v(" "),n("pre",[n("code",{staticClass:"language-stylus"},[e._v(".scroll-list-wrap\n  height: 350px\n")])]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("注意")]),e._v("：由上面的滚动原理可知，这里给滚动容器提供一个固定高度是必须的，同时只有在滚动内容的高度大于容器高度时才可滚动。")])]),e._v(" "),n("p",[e._v("在"),n("code",[e._v("options")]),e._v("中可以设置滚动条是否可见以及初始滚动位置"),n("code",[e._v("startY/startX")]),e._v("。")]),e._v(" "),n("p",[e._v("Scroll 组件提供了一个"),n("code",[e._v("scrollTo()")]),e._v("方法，可以手动控制列表滚动位置。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-javascript"},[e._v("scrollTo() {\n  this.$refs.scroll.scrollTo(\n    0,\n    this.scrollToY,\n    this.scrollToTime,\n    ease[this.scrollToEasing]\n  )\n},\n")])]),e._v(" "),n("p",[e._v("实际上这是一个非常有用的方法，如当我们想要实现“点击不同锚点，列表滚动到相应位置展现不同内容”时，可以使用"),n("code",[e._v("scrollTo()")]),e._v("方法。")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[n("strong",[e._v("2. 横向滚动 - Horizontal")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("Scroll 组件支持横向滚动，只需指定"),n("code",[e._v('direction="horizontal"')]),e._v("，同时需要添加相应样式如下。完整示例代码在"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/horizontal.vue"}},[e._v("这里")]),e._v("。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("pre",[n("code",{staticClass:"language-stylus"},[e._v(".horizontal-scroll-list-wrap\n  border: 1px solid rgba(0, 0, 0, 0.1)\n  border-radius: 5px\n  .cube-scroll-content\n    display: inline-block\n  .list-wrapper\n    padding: 0 10px\n    line-height: 60px\n    white-space: nowrap\n  .list-item\n    display: inline-block\n")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("blockquote",[n("p",[n("strong",[e._v("注意")]),e._v("：1. 由上面的滚动原理可知，这里的 CSS 样式设置是必须的，只有在滚动内容的宽度大于容器宽度时才可滚动。2. 有时候我们希望横向滚动使用"),n("code",[e._v("Scroll")]),e._v("组件来模拟，纵向保留浏览器原生滚动，或者相反的情况。这时你需要传递 better-scroll 配置项 "),n("a",{attrs:{href:"http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#eventpassthrough"}},[e._v("eventPassthrough")]),e._v("。")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("这里对样式的设定做简要的解释，为"),n("code",[e._v("list-item")]),e._v("元素添加"),n("code",[e._v("display: inline-block")]),e._v("是希望元素能够不换行，单行显示。"),n("code",[e._v("list-wrapper")]),e._v("添加"),n("code",[e._v("white-space: nowrap")]),e._v("是希望遇到父元素边界，依然不换行。另外，关键是"),n("code",[e._v("cube-scroll-content")]),e._v("元素添加"),n("code",[e._v("display: inline-block")]),e._v("样式，此时"),n("code",[e._v("cube-scroll-content")]),e._v("元素的宽度为能够包裹子孙元素的最小宽度，即为连续内联"),n("code",[e._v("list-item")]),e._v("元素的宽度之和子元素的最大宽度。具有同样性质的样式还有，浮动元素和绝对定位元素，在不设置具体宽度时，其宽度为包裹子孙元素的最小宽度。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("li",[n("p",[n("strong",[e._v("3. 自定义内容和上拉刷新下拉加载 - Customized")])]),e._v(" "),n("p",[n("code",[e._v("Scroll")]),e._v("组件支持通过插槽自定义列表内容和样式。完整示例代码在"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/config.vue"}},[e._v("这里")]),e._v("。")]),e._v(" "),n("pre",[n("code",{staticClass:"language-html"},[e._v('<div class="scroll-list-wrap">\n  <cube-scroll\n    ref="scroll"\n    :data="items"\n    :options="options"\n    @pulling-down="onPullingDown"\n    @pulling-up="onPullingUp">\n    ... // 自定义内容\n  </cube-scroll>\n</div>\n')])]),e._v(" "),n("p",[e._v("Scroll 组件还支持下拉刷新和上拉加载的能力。默认无下拉刷新/上拉加载，可通过"),n("code",[e._v("options")]),e._v("传递配置项"),n("code",[e._v("pullDownRefresh")]),e._v("和"),n("code",[e._v("pullUpLoad")]),e._v("开启相应功能。开启后，下拉时，Scroll 组件会展示默认下拉动画以及派发"),n("code",[e._v("pulling-down")]),e._v("事件，你可以监听"),n("code",[e._v("pulling-down")]),e._v("事件更新数据。同理，开启上拉加载后，可通过"),n("code",[e._v("pulling-up")]),e._v("事件更新数据。")]),e._v(" "),n("p",[n("code",[e._v("pullDownRefresh")]),e._v("的相关配置有：下拉阈值（threshold）, 回弹位置（stop）, 更新成功文案（txt）和文案显示时间（stopTime）。"),n("code",[e._v("pullDownRefresh")]),e._v("和"),n("code",[e._v("pullUpLoad")]),e._v("对象的所有配置项和含义见 "),n("a",{attrs:{href:"#/zh-CN/docs/scroll#cube-Props%E9%85%8D%E7%BD%AE-anchor"}},[e._v("Props 配置")])]),e._v(" "),n("pre",[n("code",{staticClass:"language-javascript"},[e._v("... // 省略非核心代码\ncomputed: {\n  options() {\n    return {\n      pullDownRefresh: this.pullDownRefreshObj,\n      pullUpLoad: this.pullUpLoadObj,\n      scrollbar: true\n    }\n  },\n  ...\n},\nmethods: {\n  onPullingDown() {\n    // 模拟更新数据\n    setTimeout(() => {\n      if (Math.random() > 0.5) {\n        // 如果有新数据\n        this.items.unshift(_foods[1])\n      } else {\n        // 如果没有新数据\n        this.$refs.scroll.forceUpdate()\n      }\n    }, 1000)\n  },\n  onPullingUp() {\n    // 模拟更新数据\n    setTimeout(() => {\n      if (Math.random() > 0.5) {\n        // 如果有新数据\n        let newPage = _foods.slice(0, 5)\n        this.items = this.items.concat(newPage)\n      } else {\n        // 如果没有新数据\n        this.$refs.scroll.forceUpdate()\n      }\n    }, 1000)\n  },\n  ...\n}\n")])]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("注意")]),e._v("：如果请求结果没有数据更新，则必须调用 Scroll 组件的"),n("code",[e._v("forceUpdate()")]),e._v("方法结束此次下拉刷新/上拉加载，这样 Scroll 组件才会开始监听下一次下拉刷新/上拉加载操作。在上例中数据更新时，没有调用"),n("code",[e._v("forceUpdate()")]),e._v("方法，原因为："),n("strong",[e._v("如果你向"),n("code",[e._v("Scroll")]),e._v("组件传递了"),n("code",[e._v("data")]),e._v("属性，那么当"),n("code",[e._v("Scroll")]),e._v("组件监听到"),n("code",[e._v("data")]),e._v("有更新时会自行调用"),n("code",[e._v("forceUpate(true)")]),e._v("方法")]),e._v("，因此推荐传递"),n("code",[e._v("data")]),e._v("属性。")])])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[n("strong",[e._v("4. 自定义下拉刷新动画 - 仿京东 App 首页")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("如果你不喜欢内置的下拉刷新和上拉加载动画，还可以用"),n("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"}},[e._v("作用域插槽")]),e._v("做自定义动画。Scroll 组件的作用域插槽暴露出的变量非常完善，可以满足绝大多数场景下自定义下拉/上拉动画的需求。下面的例子模仿了京东 App 首页的下拉刷新动画。完整示例代码在"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/jd.vue"}},[e._v("这里")]),e._v("。")])},function(){var e=this.$createElement,l=this._self._c||e;return l("pre",[l("code",{staticClass:"language-javascript"},[this._v("data() {\n  return {\n    options: {\n      pullDownRefresh: {\n        threshold: 60,\n        stop: 40,\n        txt: '更新成功'\n      }\n    },\n    ...\n  }\n},\ncomputed: {\n  pullDownTip() {\n    if (this.pullDownY <= 60) {\n      return '下拉刷新...'\n    } else if (this.pullDownY <= 90) {\n      return '继续下拉有惊喜...'\n    } else {\n      return '松手得惊喜！'\n    }\n  },\n  headerStyle() {\n    return Math.min(1, Math.max(0, 1 - this.pullDownY / 40))\n  }\n},\nmethods: {\n  onScrollHandle(pos) {\n    this.pullDownY = pos.y\n    if (pos.y > 0) {\n      this.pullDownStyle = `top:${pos.y}px`\n      this.triggerSurpriseFlag = false\n      if (this.pullDownY > 90) {\n        this.triggerSurpriseFlag = true\n      }\n    }\n    this.$refs.topHeader.style.opacity = this.headerStyle\n  },\n  onPullingDown() {\n    if (this.triggerSurpriseFlag) {\n      this.triggerSurprise = true\n      this.$refs.scroll.forceUpdate()\n      return\n    }\n    setTimeout(() => {\n      this.$refs.scroll.forceUpdate()\n    }, 1000)\n  },\n  ...\n}\n")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("通过作用域插槽提供的作用域参数，如："),n("code",[e._v("beforePulldown")]),e._v("和"),n("code",[e._v("isPullingDown")]),e._v("，你可以根据状态的变化来控制动画流程，其他作用域参数及其含义详见下面的"),n("a",{attrs:{href:"#/zh-CN/docs/scroll#cube-%E6%8F%92%E6%A7%BD-anchor"}},[e._v("插槽")]),e._v("。在一个完整的下拉刷新过程中，"),n("code",[e._v("beforePullDown")]),e._v("和"),n("code",[e._v("isPullingDown")]),e._v("的状态变化如下：")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("table",[n("thead",[n("tr",[n("th",[e._v("流程")]),e._v(" "),n("th",[e._v("beforePulldown")]),e._v(" "),n("th",[e._v("isPullingDown")]),e._v(" "),n("th",[e._v("备注")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("1. 未触发下拉刷新")]),e._v(" "),n("td",[e._v("true")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("展示继续下拉引导图案")])]),e._v(" "),n("tr",[n("td",[e._v("2. 触发下拉刷新")]),e._v(" "),n("td",[e._v("false")]),e._v(" "),n("td",[e._v("true")]),e._v(" "),n("td",[e._v("异步请求数据，显示 loading")])]),e._v(" "),n("tr",[n("td",[e._v("3. 获取数据成功")]),e._v(" "),n("td",[e._v("false")]),e._v(" "),n("td",[e._v("false")]),e._v(" "),n("td",[e._v("调用 "),n("code",[e._v("forceUpdate(true)")]),e._v(", 显示成功文案, 延迟 stopTime 时间进入步骤 4")])]),e._v(" "),n("tr",[n("td",[e._v("4. 下拉刷新完成")]),e._v(" "),n("td",[e._v("true")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("-")])])])])},function(){var e=this.$createElement,l=this._self._c||e;return l("p",[l("strong",[this._v("5. 高级使用 - 仿头条 App 首页")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("Scroll 组件能够满足绝大多数移动端应用的滚动需求。本例中通过横向和纵向的两个 Scroll 组件快速实现了模仿头条 App 首页的滚动体验。完整的示例代码在"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/toutiao.vue"}},[e._v("这里")]),e._v("。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("和“仿京东 APP”示例不同的是，在下拉刷新的自定义动画中，使用了"),n("code",[e._v("pulldown")]),e._v("作用域插槽中的"),n("code",[e._v("pullDownStyle")]),e._v("和"),n("code",[e._v("bubbleY")]),e._v("更方便的实现下拉动画。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[n("code",[e._v("pullDownStyle")]),e._v("用来控制下拉内容的位置，值为字符串"),n("code",[e._v("top: n px")]),e._v("（n 代表数值）。Scroll 组件是通过绝对定位的"),n("code",[e._v("top")]),e._v("值来控制下拉内容位置的。初始状态"),n("code",[e._v("top")]),e._v("值为负值，大小刚好为下拉内容的高度，因此下拉内容被隐藏到滚动区域上方，当下拉过程中，Scroll 组件会逐渐增大"),n("code",[e._v("top")]),e._v("值，实时更新下拉内容的位置。"),n("code",[e._v("top")]),e._v("最大值为0，即当下拉内容完全显示后"),n("code",[e._v("top")]),e._v("值不再增加。即 "),n("code",[e._v("pullY - height <= top <= 0")]),e._v("。（pullY 为下拉距离，height 为下拉内容高度）")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[n("code",[e._v("bubbleY")]),e._v("用来辅助实现自定义动画。在默认动画中，"),n("code",[e._v("bubbleY")]),e._v("用来控制气泡尾巴长度；在头条例子中，用来控制箭头的"),n("code",[e._v("padding-top")]),e._v("值，间接控制箭头位置。"),n("code",[e._v("bubbleY")]),e._v("的最小值为 0，下拉过程中，当下拉距离大于下拉内容高度后，"),n("code",[e._v("bubbleY")]),e._v("开始增大。即 "),n("code",[e._v("0 <= bubbleY <= pullY - height")]),e._v("。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("blockquote",[n("p",[e._v("在本例中，"),n("code",[e._v("pullDownRefresh")]),e._v("配置项没有传入"),n("code",[e._v("stop")]),e._v("值，但是下拉后依然能够回弹到正确位置，原因是 Scroll 组件初始化时会将 "),n("code",[e._v("beforePullDown === false && isPullingDown === true")]),e._v(" 时下拉内容高度作为 "),n("code",[e._v("stop")]),e._v(" 默认值。")])])},function(){var e=this.$createElement,l=this._self._c||e;return l("p",[l("strong",[this._v("6. 嵌套纵向滚动 - Vertical Scrolls")]),this._v("<sup>1.12.0</sup>")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[n("code",[e._v("Scroll")]),e._v("组件还支持嵌套的场景(目前只支持两层嵌套)。当遇到嵌套场景时，你需要给内层"),n("code",[e._v("scroll")]),e._v("组件设置 Prop nestMode，可选值有 'native' 和 'free'。当设置为 'native' 时，嵌套"),n("code",[e._v("Scroll")]),e._v("与浏览器原生嵌套场景的滚动行为相同。下面是"),n("code",[e._v("Scroll")]),e._v("组件实现纵向嵌套滚动的例子。完整的示例代码在这里"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/vertical-scrolls.vue"}},[e._v("这里")]),e._v("。")])},function(){var e=this.$createElement,l=this._self._c||e;return l("p",[l("strong",[this._v("7. 嵌套横向滚动 - Horizontal Scrolls")]),this._v("<sup>1.12.0</sup>")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("你还可以实现横向的嵌套滚动。这里同时设置"),n("code",[e._v("nestMode")]),e._v("为"),n("code",[e._v("free")]),e._v("，与"),n("code",[e._v("native")]),e._v("模式不同的是，"),n("code",[e._v("free")]),e._v("模式下，内层滚动过程中只要触发边界，便会开启外层滚动。而"),n("code",[e._v("native")]),e._v("模式下，只在开始滚动时判断是否到达边界，与浏览器原生的嵌套滚动保持一致。完整的示例代码在"),n("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/horizontal-scrolls.vue"}},[e._v("这里")]),e._v("。")])},function(){var e=this.$createElement,l=this._self._c||e;return l("p",[this._v("\x3c!-- - "),l("strong",[this._v("8. Scroll 中嵌套 textarea - Textarea")])])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("有时候我们需要在 "),n("code",[e._v("Scroll")]),e._v(" 组件中包含 teatarea 输入框。然而由于我们在使用 "),n("code",[e._v("Scroll")]),e._v(" 时禁用了浏览器 'touch' 事件的默认行为，因此我们无法在 textarea 输入框中使用浏览器的原生滚动。")])},function(){var e=this,l=e.$createElement,n=e._self._c||l;return n("p",[e._v("现在我们希望通过这个例子，介绍两种解决这个问题的方法。核心都是利用了 "),n("code",[e._v("Scroll")]),e._v(" 支持嵌套的能力，我们将内部的输入框用 "),n("code",[e._v("Scroll")]),e._v(" 进行包装，通过 "),n("code",[e._v("Scroll")]),e._v(" 去模拟滚动行为。但是有一个要求是，输入框内容区域必须是高度自适应，即高度随内容增加或减少。")])},function(){var e=this.$createElement,l=this._self._c||e;return l("p",[this._v("最后，我们还需要一些额外的工作保证输入过程中，光标能始终在视线内，保持与原生输入框的行为一致。完整的示例代码在"),l("a",{attrs:{href:"https://github.com/didi/cube-ui/blob/master/example/pages/scroll/textarea.vue"}},[this._v("这里")])])}],!1,null,null,null);l.default=o.exports}}]);